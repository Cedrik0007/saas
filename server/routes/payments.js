import express from "express";
import { ensureConnection } from "../config/database.js";
import PaymentModel from "../models/Payment.js";
import InvoiceModel from "../models/Invoice.js";
import UserModel from "../models/User.js";
import { calculateAndUpdateMemberBalance } from "../utils/balance.js";
import { sendPaymentApprovalEmail, sendPaymentRejectionEmail } from "../utils/emailHelpers.js";
import { emitInvoiceUpdate, emitMemberUpdate, emitPaymentUpdate } from "../config/socket.js";
import { approveInvoicePayment, approvePaymentAndMarkInvoicePaid } from "../services/paymentApprovalService.js";
import { resolveInvoice, resolveMember } from "../utils/resolveRefs.js";
import { getReceiptWhatsAppUrl } from "../utils/receiptLinks.js";
import { requireFinanceRole } from "../middleware/requireFinanceRole.js";

const router = express.Router();
const objectIdRegex = /^[a-f\d]{24}$/i;

const normalizeMemberId = (rawMemberId = "") =>
  typeof rawMemberId === "string" ? rawMemberId.trim() : "";

const assertValidMemberId = (value, contextLabel = "memberId") => {
  const normalized = normalizeMemberId(value);
  if (!normalized) {
    const error = new Error(`${contextLabel} is required and must be a non-empty string`);
    error.status = 400;
    throw error;
  }
  if (objectIdRegex.test(normalized)) {
    const error = new Error(`${contextLabel} must be the business identifier (e.g., IMA1234), not the Mongo _id`);
    error.status = 400;
    throw error;
  }
  return normalized;
};

const findMemberOrThrow = async (memberId) => {
  const member = await UserModel.findOne({
    $or: [
      { id: memberId },
      { "previousDisplayIds.id": memberId },
    ],
  });
  if (!member) {
    const error = new Error(`Member with ID "${memberId}" not found.`);
    error.status = 404;
    throw error;
  }
  return member;
};

const buildPaymentMemberMatch = (member) => {
  const previousIds = Array.isArray(member?.previousDisplayIds)
    ? member.previousDisplayIds.map((entry) => entry?.id).filter(Boolean)
    : [];
  const memberIdCandidates = [member?.id, ...previousIds].filter(Boolean).map(String);

  return {
    $or: [
      member?._id ? { memberRef: member._id } : null,
      memberIdCandidates.length > 0 ? { memberId: { $in: memberIdCandidates } } : null,
    ].filter(Boolean),
  };
};

// GET all payments
router.get("/", async (req, res) => {
  try {
    await ensureConnection();
    const allPayments = await PaymentModel.find({}).sort({ createdAt: -1 });
    res.json(allPayments);
  } catch (error) {
    console.error("Error fetching payments:", error);
    res.status(500).json({ error: error.message });
  }
});

// GET payments for specific member
router.get("/member/:memberId", async (req, res) => {
  try {
    await ensureConnection();

    let memberId;
    try {
      memberId = assertValidMemberId(req.params.memberId);
    } catch (validationError) {
      return res.status(validationError.status || 400).json({ error: validationError.message });
    }

    let member;
    try {
      member = await findMemberOrThrow(memberId);
    } catch (memberError) {
      return res.status(memberError.status || 404).json({ error: memberError.message });
    }

    const memberPayments = await PaymentModel.find(buildPaymentMemberMatch(member)).sort({ createdAt: -1 });
    res.json(memberPayments);
  } catch (error) {
    console.error("Error fetching member payments:", error);
    res.status(500).json({ error: error.message });
  }
});

// POST create new payment (Owner or Finance Admin only)
router.post("/", requireFinanceRole, async (req, res) => {
  try {
    await ensureConnection();

    if (Object.prototype.hasOwnProperty.call(req.body, "paymentNo")) {
      return res.status(400).json({ error: "paymentNo is generated by the backend and cannot be provided." });
    }

    let memberRecord;
    try {
      memberRecord = await resolveMember(req.body.memberId || req.body.memberRef);
    } catch (resolveError) {
      return res.status(resolveError.status || 400).json({ error: resolveError.message });
    }

    let invoiceRecord = null;
    if (req.body.invoiceId || req.body.invoiceRef) {
      try {
        invoiceRecord = await resolveInvoice(req.body.invoiceId || req.body.invoiceRef);
      } catch (resolveError) {
        return res.status(resolveError.status || 400).json({ error: resolveError.message });
      }
    }

    if (!invoiceRecord?._id) {
      return res.status(400).json({ error: "Payments must reference a valid invoice." });
    }

    const invoiceStatus = String(invoiceRecord.status || "").trim();
    if (invoiceStatus === "Paid" || invoiceStatus === "Completed") {
      return res.status(400).json({
        error: "Cannot create payment for an invoice that is already paid.",
        invoiceId: invoiceRecord.id || invoiceRecord._id,
      });
    }

    const paymentData = {
      ...req.body,
      memberRef: memberRecord._id,
      memberId: memberRecord.id || undefined,
      invoiceRef: invoiceRecord?._id,
      invoiceId: invoiceRecord?.id || undefined,
      member: req.body.member || memberRecord.name || "",
      memberEmail: req.body.memberEmail || memberRecord.email || "",
      date: req.body.date || new Date().toLocaleDateString("en-GB", {
        day: "2-digit",
        month: "short",
        year: "numeric",
      }),
      status: req.body.status || "Pending",
    };

    const newPayment = new PaymentModel(paymentData);
    await newPayment.save();

    // Emit Socket.io event for real-time update
    emitPaymentUpdate('created', newPayment);

    res.status(201).json(newPayment);
  } catch (error) {
    console.error("Error creating payment:", error);
    res.status(500).json({ error: error.message });
  }
});

// POST approve invoice payment (single-step approval by invoice _id) (Owner or Finance Admin only)
router.post("/approve-invoice", requireFinanceRole, async (req, res) => {
  try {
    await ensureConnection();

    console.log("ðŸ” DEBUG: /approve-invoice route received body:", JSON.stringify(req.body, null, 2));
    console.log("ðŸ” DEBUG: payment_date from request:", req.body.payment_date, "Type:", typeof req.body.payment_date);

    const { payment, invoice, member } = await approveInvoicePayment({
      invoiceRef: req.body.invoiceId,
      memberRef: req.body.memberId,
      amount: req.body.amount,
      paymentType: req.body.payment_type,
      method: req.body.method,
      receiverName: req.body.receiver_name,
      reference: req.body.reference,
      screenshot: req.body.screenshot,
      date: req.body.date,
      payment_date: req.body.payment_date,
      paidToAdmin: req.body.paidToAdmin,
      paidToAdminName: req.body.paidToAdminName,
      approvedBy: req.body.approvedBy || req.body.adminName || req.body.adminId,
    });

    if (member?.id) {
      await calculateAndUpdateMemberBalance(member.id);
    }

    emitPaymentUpdate('created', payment);
    if (invoice) {
      emitInvoiceUpdate('updated', invoice);
    }
    if (member) {
      emitMemberUpdate('updated', member);
    }

    const receiptPdfUrl = invoice?._id
      ? await getReceiptWhatsAppUrl(invoice)
      : null;
    
    console.log("ðŸ“¤ DEBUG: Returning invoice in response with payment_date:", invoice?.payment_date);
    console.log("ðŸ“¤ DEBUG: Full invoice object being returned:", JSON.stringify({
      _id: invoice._id,
      id: invoice.id,
      status: invoice.status,
      payment_date: invoice.payment_date,
      last_payment_date: invoice.last_payment_date,
    }, null, 2));
    
    res.json({ success: true, payment, invoice, member, receiptPdfUrl });
  } catch (error) {
    console.error("Error approving invoice payment:", error);
    const statusCode = error.status || error.statusCode || 500;
    res.status(statusCode).json({ error: error.message });
  }
});

// PUT approve payment (Owner or Finance Admin only)
router.put("/:id/approve", requireFinanceRole, async (req, res) => {
  try {
    await ensureConnection();

    const { payment, invoice, member } = await approvePaymentAndMarkInvoicePaid({
      paymentId: req.params.id,
      adminId: req.body.adminId,
      adminName: req.body.adminName,
    });

    if (member?.id) {
      await calculateAndUpdateMemberBalance(member.id);
    }

    if (member && invoice) {
      try {
        await sendPaymentApprovalEmail(member, payment, invoice);
      } catch (emailError) {
        console.warn("âš  Payment approved, but email failed:", emailError?.message || emailError);
      }
    }

    emitPaymentUpdate('updated', payment);
    if (invoice) {
      emitInvoiceUpdate('updated', invoice);
    }

    const receiptPdfUrl = invoice?._id
      ? await getReceiptWhatsAppUrl(invoice)
      : null;
    res.json({ success: true, payment, invoice, receiptPdfUrl });
  } catch (error) {
    console.error("Error approving payment:", error);
    const statusCode = error.status || error.statusCode || 500;
    res.status(statusCode).json({ error: error.message });
  }
});

// PUT reject payment (Owner or Finance Admin only)
router.put("/:id/reject", requireFinanceRole, async (req, res) => {
  try {
    await ensureConnection();

    // Try to find by _id first, then by id field
    let payment = await PaymentModel.findById(req.params.id);
    if (!payment) {
      payment = await PaymentModel.findOne({ id: req.params.id });
    }
    if (!payment) {
      return res.status(404).json({ message: "Payment not found" });
    }

    // Update payment status
    payment.status = "Rejected";
    payment.rejectionReason = req.body.reason || "";
    payment.rejectedBy = req.body.adminId || req.body.adminName || "Admin";
    payment.rejectedAt = new Date();
    await payment.save();

    // Get related invoice and member for email
    let invoice = null;
    let member = null;

    if (payment.invoiceId) {
      if (objectIdRegex.test(payment.invoiceId)) {
        invoice = await InvoiceModel.findById(payment.invoiceId);
      } else {
        invoice = await InvoiceModel.findOne({ id: payment.invoiceId });
      }
    }

    let normalizedMemberId;
    try {
      normalizedMemberId = assertValidMemberId(payment.memberId, "payment.memberId");
    } catch (validationError) {
      return res.status(validationError.status || 400).json({ error: validationError.message });
    }
    payment.memberId = normalizedMemberId;

    try {
      member = await findMemberOrThrow(normalizedMemberId);
    } catch (memberError) {
      return res.status(memberError.status || 404).json({ error: memberError.message });
    }

    // Update related invoice back to Unpaid
    if (payment.invoiceId) {
      const invoiceQuery = objectIdRegex.test(payment.invoiceId)
        ? { _id: payment.invoiceId }
        : { id: payment.invoiceId };
      await InvoiceModel.findOneAndUpdate(
        invoiceQuery,
        {
          $set: {
            status: "Unpaid",
            method: "",
            reference: "",
            screenshot: ""
          }
        }
      );

      // Update member balance
      await calculateAndUpdateMemberBalance(normalizedMemberId);
    }

    // Send rejection email
    if (member) {
      await sendPaymentRejectionEmail(member, payment, invoice, payment.rejectionReason);
    }

    // Emit Socket.io event for real-time update
    emitPaymentUpdate('updated', payment);

    res.json({ success: true, payment });
  } catch (error) {
    console.error("Error rejecting payment:", error);
    res.status(500).json({ error: error.message });
  }
});

// PUT update payment
router.put("/:id", requireFinanceRole, async (req, res) => {
  try {
    await ensureConnection();

    // Try to find by _id first, then by id field
    let payment = await PaymentModel.findById(req.params.id);
    if (!payment) {
      payment = await PaymentModel.findOne({ id: req.params.id });
    }
    if (!payment) {
      return res.status(404).json({ message: "Payment not found" });
    }

    // Update payment fields
    const updateData = { ...req.body };
    delete updateData._id; // Don't allow _id updates
    delete updateData.id; // Don't allow id updates

    if (Object.prototype.hasOwnProperty.call(updateData, "memberId")) {
      try {
        updateData.memberId = assertValidMemberId(updateData.memberId);
      } catch (validationError) {
        return res.status(validationError.status || 400).json({ error: validationError.message });
      }

      try {
        await findMemberOrThrow(updateData.memberId);
      } catch (memberError) {
        return res.status(memberError.status || 404).json({ error: memberError.message });
      }
    }

    Object.assign(payment, updateData);
    await payment.save();

    // Emit Socket.io event for real-time update
    emitPaymentUpdate('updated', payment);

    res.json({ success: true, payment });
  } catch (error) {
    console.error("Error updating payment:", error);
    res.status(500).json({ error: error.message });
  }
});

// DELETE payment (Owner or Finance Admin only)
router.delete("/:id", requireFinanceRole, async (req, res) => {
  try {
    await ensureConnection();

    // Try to find by _id first, then by id field
    let payment = await PaymentModel.findById(req.params.id);
    if (!payment) {
      payment = await PaymentModel.findOne({ id: req.params.id });
    }
    if (!payment) {
      return res.status(404).json({ message: "Payment not found" });
    }

    // If payment was approved and has an invoice, revert invoice status
    if (payment.status === "Completed" && payment.invoiceId) {
      await InvoiceModel.findOneAndUpdate(
        { id: payment.invoiceId },
        {
          $set: {
            status: "Unpaid",
            method: "",
            reference: "",
            screenshot: ""
          }
        }
      );

      // Update member balance
      if (payment.memberId) {
        await calculateAndUpdateMemberBalance(payment.memberId);
      }
    }

    // Delete the payment
    await PaymentModel.findByIdAndDelete(payment._id);

    res.json({ success: true, message: "Payment deleted successfully" });
  } catch (error) {
    console.error("Error deleting payment:", error);
    res.status(500).json({ error: error.message });
  }
});

export default router;

